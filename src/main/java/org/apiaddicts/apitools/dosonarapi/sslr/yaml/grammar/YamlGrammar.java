/*
 * doSonarAPI SSLR :: YAML Parser
 * Copyright (C) 2021-2022 Apiaddicts
 * contacta AT apiaddicts DOT org
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.apiaddicts.apitools.dosonarapi.sslr.yaml.grammar;

import javax.annotation.Nullable;

import org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Lexer;
import org.sonar.sslr.grammar.GrammarRuleKey;
import org.sonar.sslr.grammar.LexerfulGrammarBuilder;
import org.apiaddicts.apitools.dosonarapi.sslr.yaml.grammar.impl.ArrayNode;
import org.apiaddicts.apitools.dosonarapi.sslr.yaml.grammar.impl.ObjectNode;
import org.apiaddicts.apitools.dosonarapi.sslr.yaml.grammar.impl.PropertyNode;
import org.apiaddicts.apitools.dosonarapi.sslr.yaml.grammar.impl.ScalarNode;
import org.apiaddicts.apitools.dosonarapi.sslr.yaml.grammar.impl.SyntaxNode;
import org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens;

import static com.sonar.sslr.api.GenericTokenType.EOF;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.BLOCK_END;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.BLOCK_ENTRY;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.BLOCK_MAPPING_START;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.BLOCK_SEQUENCE_START;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.FALSE;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.FLOAT;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.FLOW_MAPPING_END;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.FLOW_MAPPING_START;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.FLOW_SEQUENCE_END;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.FLOW_SEQUENCE_START;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.INTEGER;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.KEY;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.NULL;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.STRING;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.TRUE;
import static org.apiaddicts.apitools.dosonarapi.sslr.yaml.snakeyaml.parser.Tokens.VALUE;

/**
 * The generic YAML Grammar. Can be used as-is with the SSLR toolkit to generate an AST from a YAML document.
 */
public enum YamlGrammar implements GrammarRuleKey {
  ROOT(null),
  // Invisible in the AST
  BLOCK_OR_INDENTLESS(null),
  BLOCK_CONTENT(null),
  FLOW_CONTENT(null),
  BLOCK_COLLECTION(null),
  FLOW_COLLECTION(null),
  FLOW_SEQUENCE_ENTRY(null),
  // Visible in the AST
  INDENTLESS_SEQUENCE(ArrayNode.class),
  BLOCK_SEQUENCE(ArrayNode.class),
  BLOCK_MAPPING(ObjectNode.class),
  BLOCK_PROPERTY(PropertyNode.class),
  FLOW_SEQUENCE(ArrayNode.class),
  FLOW_MAPPING(ObjectNode.class),
  FLOW_PROPERTY(PropertyNode.class),
  FLOW_ARRAY_ELEMENT(SyntaxNode.class),
  BLOCK_ARRAY_ELEMENT(SyntaxNode.class),
  SCALAR(ScalarNode.class),
  // Generated by second pass parsing
  MISSING(SyntaxNode.class);

  private final Class<? extends JsonNode> nodeClass;

  YamlGrammar(@Nullable Class<? extends JsonNode> nodeClass) {
    this.nodeClass = nodeClass;
  }

  public Class<? extends JsonNode> getNodeClass() {
    return this.nodeClass;
  }

  /**
   * Builds an SSLR-compatible grammar descriptor for YAML. It is designed to be used in conjunction with the
   * {@link Lexer}.
   *
   * @return a new builder with a configured YAML grammar
   */
  public static LexerfulGrammarBuilder create() {
    LexerfulGrammarBuilder b = LexerfulGrammarBuilder.create();
    b.setRootRule(ROOT);
    b.rule(ROOT).is(b.optional(BLOCK_CONTENT), EOF); // Important: comments may be associated to the EOF token

    b.rule(BLOCK_OR_INDENTLESS).is(b.firstOf(INDENTLESS_SEQUENCE, BLOCK_CONTENT)).skip();
    b.rule(BLOCK_CONTENT).is(b.firstOf(SCALAR, BLOCK_COLLECTION, FLOW_COLLECTION)).skip();
    b.rule(FLOW_CONTENT).is(b.firstOf(SCALAR, FLOW_COLLECTION)).skip();
    b.rule(BLOCK_COLLECTION).is(b.firstOf(BLOCK_SEQUENCE, BLOCK_MAPPING)).skip();
    b.rule(FLOW_COLLECTION).is(b.firstOf(FLOW_SEQUENCE, FLOW_MAPPING)).skip();
    b.rule(FLOW_SEQUENCE_ENTRY).is(b.firstOf(FLOW_CONTENT, FLOW_PROPERTY)).skip();

    b.rule(INDENTLESS_SEQUENCE).is(b.oneOrMore(BLOCK_ENTRY, b.optional(BLOCK_ARRAY_ELEMENT)));
    b.rule(BLOCK_SEQUENCE).is(b.sequence(BLOCK_SEQUENCE_START, b.zeroOrMore(BLOCK_ENTRY, b.optional(BLOCK_ARRAY_ELEMENT)), BLOCK_END));
    b.rule(BLOCK_ARRAY_ELEMENT).is(BLOCK_CONTENT);
    b.rule(BLOCK_MAPPING).is(b.sequence(BLOCK_MAPPING_START,
      b.zeroOrMore(BLOCK_PROPERTY),
      BLOCK_END));
    b.rule(BLOCK_PROPERTY).is(b.sequence(
        KEY,
        b.optional(BLOCK_OR_INDENTLESS),
        b.optional(VALUE, b.optional(BLOCK_OR_INDENTLESS))));
    b.rule(FLOW_SEQUENCE).is(b.sequence(FLOW_SEQUENCE_START,
      b.zeroOrMore(FLOW_ARRAY_ELEMENT, Tokens.FLOW_ENTRY),
      b.optional(FLOW_ARRAY_ELEMENT),
      FLOW_SEQUENCE_END));
    b.rule(FLOW_ARRAY_ELEMENT).is(FLOW_SEQUENCE_ENTRY);
    b.rule(FLOW_MAPPING).is(b.sequence(FLOW_MAPPING_START,
      b.zeroOrMore(FLOW_SEQUENCE_ENTRY, Tokens.FLOW_ENTRY),
      b.optional(FLOW_SEQUENCE_ENTRY),
      FLOW_MAPPING_END));
    b.rule(FLOW_PROPERTY).is(b.sequence(KEY, b.optional(FLOW_CONTENT), b.optional(VALUE, b.optional(FLOW_CONTENT))));
    b.rule(SCALAR).is(b.firstOf(NULL, TRUE, FALSE, INTEGER, FLOAT, STRING));
    return b;
  }
}
